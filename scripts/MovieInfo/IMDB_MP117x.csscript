//css_reference "core.dll";
//css_reference "Databases.dll";
//css_reference "utils.dll";
//css_reference "Newtonsoft.Json.dll";

using MediaPortal.GUI.Library;
using MediaPortal.Util;
using MediaPortal.Video.Database;

using Newtonsoft.Json;

using System;
using System.Text;
using System.IO;
using System.Net;
using System.Collections;
using System.Web;
using System.Text.RegularExpressions;

using System.Windows.Forms;

internal class Grabber : MarshalByRefObject, IIMDBScriptGrabber
{
  const string strGrabber = "IMDB_MP117x";
  const string strGrabberVersion = "20230419.I";

  public const string TITLE_MASK = "{0}{1}{2}";                 // {0} - Title {1} - Separator {2} - Original Title {3} - Year
  public const string TITLE_SEPARATOR = " / ";

  public void FindFilm(string strSearch, int iLimit, ArrayList elements)
  {
    Log.Info("{0} Version: {1}", strGrabber, strGrabberVersion);
    Log.Debug("{0} Search start: {1} {2}", strGrabber, strSearch, iLimit);
    
    int year = 0; // Year from search string
    int yearIMDB = 0; // Year from IMDB movie
    int yAcc = 1; // Year accuracy check - checks in searchstring for (year number) or [year number]

    string regexPattern = string.Empty;

    // If string contains tt number use it
    if (Regex.Match(strSearch, @"tt\d{7,8}").Success)
    {
      string ttNumber = Regex.Match(strSearch, @"(?<imdbID>tt\d{7,8})").Groups["imdbID"].Value;
      string imdbUrl = string.Format(IMDB_BaseUrl, ttNumber);
      IMDB.IMDBUrl url = new IMDB.IMDBUrl(imdbUrl, ttNumber, strGrabber);
      elements.Add(url);
      Log.Info("{0} Direct IMDB ID link [{1}] added from search string: [{2}]", strGrabber, imdbUrl, strSearch);
      return;
    }

    // Get year from search string
    Regex rx = new Regex(@"^(.*)?[\[\(](19\d{2}|20\d{2})[\]\)]");
    Match match = rx.Match(strSearch);

    if (match.Success)
    {
      year = int.Parse(match.Groups[2].Value);
      strSearch = Regex.Replace(strSearch, @"\+[\[\(](19\d{2}|20\d{2})[\]\)]", string.Empty).Trim();
    }

    // If year is empty try workaround
    if (year == 0)
    {
      rx = new Regex(@"\+(\d\d\d\d$)");
      MatchCollection mcYear = rx.Matches(strSearch);
      if (mcYear.Count > 0)
      {
        int lastIndex = mcYear.Count - 1;
        year = Convert.ToInt32(mcYear[lastIndex].Value);
      }
    }

    // Try to find year without brackets
    if (year == 0)
    {
      string strYearIMDB = Regex.Match(strSearch, @"\+\d\d\d\d").Value.Replace("+", "");

      if (!string.IsNullOrEmpty(strYearIMDB))
      {
        strYearIMDB = "+(" + strYearIMDB + ")";
        strSearch = Regex.Replace(strSearch, @"\+\d\d\d\d", strYearIMDB);
        rx = new Regex(@"^(.*)?[\[\(](19\d{2}|20\d{2})[\]\)]");
        match = rx.Match(strSearch);
      }

      if (match.Success)
      {
        year = int.Parse(match.Groups[2].Value);
        strSearch = Regex.Replace(strSearch, @"\+[\[\(](19\d{2}|20\d{2})[\]\)]", string.Empty).Trim();
      }
    }

    Log.Info("{0} Search for: {1}, Year: {2}", strGrabber, strSearch, year > 0 ? year.ToString() : "-");

    try
    {
      string absoluteUri;
      string strUrl = string.Format(IMDB_Find, strSearch);
      Log.Debug("{0} Search url: {1}", strGrabber, strUrl);

      string strBody = GetPage(strUrl, "utf-8", out absoluteUri);
      // strBody = Regex.Match(strBody, @"<section\sclass=""posters"">.*?</section>", RegexOptions.IgnoreCase | RegexOptions.Singleline | RegexOptions.Compiled).Value;

      // Direct hit test
      if (strBody.Contains("<div class=\"mainInfo\">"))
      {
        regexPattern = @"<title>(?<movieTitle>.*?)[(].*?(?<movieYear>\d{4})";
        string strTitle = Regex.Match(strBody, regexPattern).Groups["movieTitle"].Value.Replace("IMDb -", string.Empty).Trim();
        // Year
        string strYear = Regex.Match(strBody, regexPattern).Groups["movieYear"].Value;

        if (strTitle != string.Empty && strYear != string.Empty)
        {
          HTMLUtil htmlUtil = new HTMLUtil();
          htmlUtil.ConvertHTMLToAnsi(strTitle, out strTitle);
          strTitle = strTitle.Replace("\n", "");
          IMDB.IMDBUrl url = new IMDB.IMDBUrl(absoluteUri.Replace("m.imdb", "www.imdb"), strTitle, strGrabber);
          elements.Add(url);
          Log.Info("{0} Direct hit for search string [{1}]", strGrabber, strSearch);
        }
        return;
      }

      // regexPattern = @"<a\shref=""/title/(?<ttnumber>.*?)/.*?>(?<title>.*?)</a>(?<option>.*?)</div>";
      // regexPattern = @"<a\shref=.\/title\/(?<ttnumber>tt\d+?)\/[\s\S]+?span[^>]+?h3.>(?<title>[^<]+?)<\/span>[^<]+?<div class=.unbold.>[^<]*?\((?<year>\d{4})\)[^<]*?(?:\((?<option>[^<]+?)\)[^<]*?)?<";
      regexPattern = @"href=.\/title\/(?<ttnumber>tt\d+?)\/[^>]+?>(?<title>[^<]+?)<\/a><ul[^>]+?><li[^>]+?><span[^>]+?>(?<year>\d{4})<\/span";

      MatchCollection mc = Regex.Matches(strBody, regexPattern, RegexOptions.IgnoreCase | RegexOptions.Singleline);
      if (mc.Count != 0)
      {
        Log.Info("{0} Found {1} matching movies for {2}. Filtering results.", strGrabber, mc.Count, strSearch);
        foreach (Match m in mc)
        {
          string ttnumber = string.Empty;
          string title = string.Empty;
          string syear = string.Empty;
          // string option = string.Empty;

          ttnumber = m.Groups["ttnumber"].Value;
          title = m.Groups["title"].Value;
          syear = m.Groups["year"].Value;
          /*
          option = m.Groups["option"].Value.Trim();
          bool bSkipThisEntry = option.ToLowerInvariant().Contains("tv series") ||
                                option.ToLowerInvariant().Contains("tv mini-series") ||
                                option.ToLowerInvariant().Contains("tv special") ||
                                option.ToLowerInvariant().Contains("tv short") ||
                                option.ToLowerInvariant().Contains("vg") ||
                                option.ToLowerInvariant().Contains("tv episode") ||
                                option.ToLowerInvariant().Contains("short") ||
                                option.ToLowerInvariant().Contains("video game");
          if (!bSkipThisEntry && year != 0)
          */
          bool bSkipThisEntry = false;
          if (year != 0)
          {
            if (!string.IsNullOrEmpty(syear))
            {
              if (!Int32.TryParse(syear, out yearIMDB))
              {
                bSkipThisEntry = true;
              }
            }

            if (!bSkipThisEntry)
            {
              if (year != yearIMDB && (year - yAcc) != yearIMDB && (year + yAcc) != yearIMDB)
              {
                bSkipThisEntry = true;
              }
            }
          }

          if (!bSkipThisEntry)
          {
            string pageLink = string.Format(IMDB_BaseUrl, ttnumber);
            title = title.Replace("\n", "");
            // IMDB.IMDBUrl url = new IMDB.IMDBUrl(pageLink, string.Format("{0} ({2}) {1}", title, option, syear), strGrabber);
            IMDB.IMDBUrl url = new IMDB.IMDBUrl(pageLink, string.Format("{0} ({1})", title, syear), strGrabber);
            elements.Add(url);
          }
        }
        Log.Info("{0} Total returned movie count {1}", strGrabber, elements.Count);
      }
      else
      {
        Log.Info("{0} Movies not found for {1}", strGrabber, strSearch);
      }
    }
    catch (Exception ex)
    {
      Log.Error("{0} Exception for IMDB lookup of {1} err:{2} stack:{3}", strGrabber, strSearch, ex.Message, ex.StackTrace);
    }
  }

  //Movie details
  public bool GetDetails(IMDB.IMDBUrl url, ref IMDBMovie movieDetails)
  {
    Log.Info("{0} Version: {1}", strGrabber, strGrabberVersion);

    try
    {
      movieDetails.Reset();
      movieDetails.Database = strGrabber;
      Log.Info("{0} Script GetDetails for: {1}", strGrabber, url.URL);

      string strAbsUrl;
      string strBody = GetPage(url.URL, "utf-8", out strAbsUrl);

      if (string.IsNullOrEmpty(strBody))
      {
        return false;
      }

      string regexBlockPattern = string.Empty;
      string regexPattern = string.Empty;
      string block = string.Empty;

      // IMDB Number
      int iPos = strAbsUrl.IndexOf("/title/");

      if (iPos > 0)
      {
        iPos += "/title/".Length;
        movieDetails.IMDBNumber = strAbsUrl.Substring(iPos);
        int pos = movieDetails.IMDBNumber.IndexOf("/");

        if (pos > 0)
        {
          movieDetails.IMDBNumber = movieDetails.IMDBNumber.Substring(0, pos);
        }
      }

      string regex = @"type=.application\/ld\+json.>(?<json>{.+?})<";
      string json = Regex.Match(page, regex, RegexOptions.Singleline | RegexOptions.IgnoreCase).Groups["json"].Value;
      if (string.IsNullOrEmpty(json))
      {
        Log.Debug("{0} GetDetails IMDB = {1}, JSON not found.", strGrabber, imdbID);
        return false;
      }
      json = json.Replace(@"""@", @"""");

      try
      {
        JsonIMDBMovie Movie = JsonConvert.DeserializeObject<JsonIMDBMovie>(json);
        if (Movie == null)
        {
          Log.Debug("{0} GetDetails IMDB = {1}, JSON changed!?.", strGrabber, imdbID);
          return false;
        }

        string sYear = !string.IsNullOrWhiteSpace(Movie.dateCreated) && Movie.dateCreated.Length >= 4 ? Movie.dateCreated.Substring(0, 4) : string.Empty;

        // Make Title by TITLE_MASK {0} - Title {1} - Separator {2} - Original Title {3} - Year
        string ResultTitleMask = TITLE_MASK;
        if (!string.IsNullOrEmpty(ResultTitleMask))
        {
          if (Movie.name.Equals(Movie.alternateName, StringComparison.CurrentCultureIgnoreCase))
          {
            ResultTitleMask = ResultTitleMask.Replace("{1}", string.Empty).Replace("{2}", string.Empty).Trim();
          }
          if (string.IsNullOrEmpty(Movie.name) || string.IsNullOrEmpty(Movie.alternateName))
          {
            ResultTitleMask = ResultTitleMask.Replace("{1}", string.Empty).Trim();
          }
          if (string.IsNullOrEmpty(sYear))
          {
            ResultTitleMask = ResultTitleMask.Replace("({3})", string.Empty).Replace("[{3])", string.Empty).Replace("{3}", string.Empty).Trim();
          }

          movieDetails.Title = string.Format(ResultTitleMask, oReturn.Title, TITLE_SEPARATOR, oReturn.OriginalTitle, sYear);
          if (!string.IsNullOrEmpty(movieDetails.Title))
          {
            movieDetails.Title = movieDetails.Title.Trim();
          }

        }

        if (!string.IsNullOrEmpty(sYear))
        {
          int iYear;
          int.TryParse(sYear, out iYear);
          movieDetails.Year = iYear;
        }
        Log.Debug("{0} IMDB {1}: {2} ({3})", "Name", strGrabber, movieDetails.Title, movieDetails.Year);

        movieDetails.ThumbURL = Movie.image.Replace(".jpg","SX500.jpg");

        // Director
        if (Movie.director != null && Movie.director.Count > 0)
        {
          foreach (JsonIMDBActor director in Movie.director)
          {
            if (director.type == "Person")
            {
              movieDetails.Director = director.name;
              break;
            }
        }

        // Writers
        if (Movie.creator != null && Movie.creator.Count > 0)
        {
          foreach (JsonIMDBActor creator in Movie.creator)
          {
            if (creator.type == "Person")
            {
              movieDetails.WritingCredits += (!string.IsNullOrEmpty(movieDetails.WritingCredits) ? " / " : string.Empty) + creator.name;
            }
        }

        // Genres
        if (Movie.genre != null && Movie.genre.Count > 0)
        {
          foreach (string genre in Movie.genre)
          {
            movieDetails.Genre += (!string.IsNullOrEmpty(movieDetails.Genre) ? " / " : string.Empty) + genre;
        }

        // MPAA Rating
        // No user country or IMDB USA, show NR
        if (!string.IsNullOrEmpty(Movie.contentRating))
        {
          movieDetails.MPARating = Movie.contentRating;
        }
        else
        {
          movieDetails.MPARating = "NR";
        }

        // Rating
        if (Movie.aggregateRating != null)
        {
          movieDetails.Rating = (float)Movie.aggregateRating.ratingValue;

          if (movieDetails.Rating > 10.0f)
          {
            movieDetails.Rating /= 10.0f;
          }
          movieDetails.Votes = Movie.aggregateRating.ratingCount.ToString();
        }

      }
      catch (Exception ex)
      {
        Log.Debug("{0} GetDetails IMDB = {1}, Exception {2}, JSON changed!?.", strGrabber, imdbID, ex.Message);
        return false;
      }

      // Actors
      // regexPattern =  @"href=""/name/nm\d{7,8}/.*?alt=""(?<actor>.*?)"".*?<td.class=""character"">.*?<div>(?<role>.*?)</div>";
      // regexBlockPattern = @"<table class=.cast.>.*?<\/table>|<table class=.cast_list.>.*?<\/table>";
      regexBlockPattern = @"<span>Top cast<\/span>.+?Director<\/span>";
      // regexPattern =  @"href=.\/name\/nm\d{7,8}\/.*?alt=""(?<actor>.*?)"".*?<td.class=.character.>.*?<a[^>]+?>(?<role>.*?)<\/a>";
      regexPattern =  @"href=.\/name\/nm\d{7,8}\/.*?label=.(?<actor>.*?).>.+?href=.\/title\/tt\d{7,8}\/characters\/nm\d{7,8}.*?cast-item-characters-link.><span class=[^>]+?>(?<role>.*?)<\/span>";
      Match castBlock = Regex.Match(strBody, regexBlockPattern, RegexOptions.Singleline);
      string strCastBlock = HttpUtility.HtmlDecode(castBlock.Value);

      if (!string.IsNullOrEmpty(strCastBlock))
      {
        MatchCollection mc = Regex.Matches(strCastBlock, regexPattern, RegexOptions.Singleline);

        string strActor = string.Empty;
        string strRole = string.Empty;

        if (mc.Count != 0)
        {
          foreach (Match m in mc)
          {
            strActor = string.Empty;
            strActor = m.Groups["actor"].Value;
            strActor = Utils.stripHTMLtags(strActor).Trim().Replace("\n", "");
            string htmlDecode = HttpUtility.HtmlDecode(strActor);

            if (htmlDecode != null)
            {
              strActor = htmlDecode.Replace(",", ";");
              strRole = string.Empty;
              strRole = m.Groups["role"].Value;
              strRole = Utils.stripHTMLtags(strRole).Trim().Replace("\n", "");
              string decode = HttpUtility.HtmlDecode(strRole);

              if (decode != null)
              {
                strRole = decode.Replace(",", ";").Replace("  ", "").Replace("(", " (").Replace(" /", "/");
                string regex = "(\\(.*\\))";
                strRole = Regex.Replace(strRole, regex, "").Trim();
                movieDetails.Cast += strActor;

                if (strRole != string.Empty)
                {
                  movieDetails.Cast += " as " + strRole;
                }

                movieDetails.Cast += "\n";
              }
            }
          }
        }
      }

      // Studios
      movieDetails.Studios = GetStudiosIMDB(strBody);

      // Country
      // regexBlockPattern = @"<h4\sclass=""inline"">Country:</h4>.*?<h4";
      regexBlockPattern = @"Country of origin<\/span>.*?<\/div>";
      regexPattern = @"href=.[^>]+?country[^>]+?>(?<country>[^<]+)<\/a>";
      block = Regex.Match(strBody, regexBlockPattern, RegexOptions.Singleline).Value.Replace("\n", string.Empty);
      MatchCollection mcCountry = Regex.Matches(block, regexPattern, RegexOptions.Singleline);
      string country = string.Empty;

      foreach (Match ms in mcCountry)
      {
        country = country + ms.Groups["country"].Value + " / ";
      }
      try
      {
        if (!string.IsNullOrEmpty(country))
        {
          movieDetails.Country = country.Remove(country.LastIndexOf(" / "));
        }
      }
      catch (Exception ex)
      {
        Log.Error("{0} GetCountry error: {1}", strGrabber, ex.Message);
      }

      // Language from IMDB
      /*
      regexPattern = @"<h4\sclass=""inline"">Language:</h4>.*?url'>(?<language>.*?)</a>";
      string language = Regex.Match(strBody, regexPattern, RegexOptions.Singleline).Groups["language"].Value;
      movieDetails.Language = language;
      */

      // regexBlockPattern = @"<h4\sclass=""inline"">Language:</h4>.*?</div>";
      regexBlockPattern = @"Language<\/span>.*?<\/div>";
      regexPattern = @"href=.[^>]+?language[^>]+?>(?<language>[^<]+)<\/a>";
      block = Regex.Match(strBody, regexBlockPattern, RegexOptions.Singleline).Value;
      MatchCollection mcLanguages = Regex.Matches(block, regexPattern, RegexOptions.Singleline);
      string languages = string.Empty;

      foreach (Match ml in mcLanguages)
      {
        languages = languages + Utils.stripHTMLtags(ml.Groups["language"].Value) + ", ";
      }

      if (!string.IsNullOrEmpty(languages))
      {
        movieDetails.Language = HttpUtility.HtmlDecode(languages.Remove(languages.LastIndexOf(", ")));
        Log.Debug("{0} Languages: {1}", strGrabber, movieDetails.Language);
      }

      // IMDB MPAA Rating / MPAA Text Description MP1-4846
      string pageURL = string.Format(IMDB_Parents, movieDetails.IMDBNumber);
      string page = GetWebServerResponse(pageURL);
      movieDetails.MPAAText = GetMPARatingText(page);

      // Runtime
      // regexPattern = "<time\\sitemprop=\"duration\".*?(?<movieRuntime>\\d+)\\smin";
      // regexPattern = @"inline.>Runtime:[^>]+?>[^<]*?<time[^>]*?>(?<movieRuntime>\d+)\smin";
      regexPattern = @".runtime.:{.seconds.:(?<movieRuntime>\d+),.displayableProperty.";

      int runtime;

      if (int.TryParse(Regex.Match(strBody, regexPattern).Groups["movieRuntime"].Value, out runtime))
      {
        movieDetails.RunTime = runtime / 60;
      }

      // Tagline
      regexPattern = @"<h5>Tagline.</h5>[^>]+>[^\r]?(?<movieTagline>[^<]+)|<h4[^>]*>Tagline[s]?:</h4>[\s\f\r]*(?<movieTagline>[^<]+)";
      string tagline = Regex.Match(strBody, regexPattern).Groups["movieTagline"].Value.Replace("\n", string.Empty);
      tagline = Regex.Replace(tagline, @"\[.*?\]", string.Empty);
      movieDetails.TagLine = HttpUtility.HtmlDecode(tagline.Trim());
      
      // Plot short
      // regexPattern = @"<p\sitemprop=""description"">(?<moviePlotShort>.*?)</p>";
      // regexPattern = @"<div class=.summary_text.\sitemprop=.description.>(?<moviePlotShort>.*?)(?:<\/div>|<a href=[^>]+?>See)";
      regexPattern = @"<h2>Storyline<\/h2>[^<]+?<div[^>]+?>[^<]+?<p[^>]*?>[^<]+<span[^>]*?>(?<moviePlotShort>[^<]+?)<";
      string shortPlot = Regex.Match(strBody, regexPattern, RegexOptions.Singleline).Groups["moviePlotShort"].Value;
      shortPlot = HttpUtility.HtmlDecode(Utils.stripHTMLtags(shortPlot));

      if (shortPlot != null)
      {
        movieDetails.PlotOutline = shortPlot.Trim();
      }

      // Plot long
      string strPlotUrl = string.Format(IMDB_Plot, movieDetails.IMDBNumber);
      try
      {
        string absoluteUri;
        string strPlotHtml = GetPage(strPlotUrl, "utf-8", out absoluteUri);

        // regexBlockPattern = @">Plot\sSummary.*?<footer\sclass=";
        regexBlockPattern = @"<section id=.plot-summaries-content.>.+?<\/section";
        strPlotHtml = Regex.Match(strPlotHtml, regexBlockPattern,
                      RegexOptions.IgnoreCase |
                      RegexOptions.IgnorePatternWhitespace |
                      RegexOptions.Singleline |
                      RegexOptions.Compiled).Value;

        if (strPlotHtml.Length != 0)
        {
          // regexPattern = @"<p\sclass=""text-large"">(?<moviePlot>.+?)</p>";
          /*
          movieDetails.Plot = Regex.Match(strPlotHtml, regexPattern,
                              RegexOptions.IgnoreCase |
                              RegexOptions.IgnorePatternWhitespace |
                              RegexOptions.Singleline |
                              RegexOptions.Compiled).Value;
          */
          movieDetails.Plot = strPlotHtml;
          movieDetails.Plot = Utils.stripHTMLtags(movieDetails.Plot);
          movieDetails.Plot = HttpUtility.HtmlDecode(movieDetails.Plot); // remove HTML entities
        }

        if (movieDetails.Plot == string.Empty)
        {
          movieDetails.Plot = movieDetails.PlotOutline;
        }

        if (movieDetails.PlotOutline == string.Empty)
        {
          movieDetails.PlotOutline = movieDetails.Plot;
        }
      }
      catch (Exception ex)
      {
        Log.Error("{0} GetPlotDetails error: {1}", strGrabber, ex.Message);
      }

      if (movieDetails.RunTime == 0)
      {
        string strTechUrl = string.Format(IMDB_Tech, movieDetails.IMDBNumber);
        try
        {
          string absoluteUri;
          string strTechHtml = GetPage(strTechUrl, "utf-8", out absoluteUri);

          regexPattern = @">\s*?Runtime[^>]+?>[^<]*?<td[^>]*?>[^<]*?\((?<movieRuntime>\d+)\smin";

          Log.Debug("{0} IMDB RunTime: {1}", strGrabber, Regex.Match(strTechHtml, regexPattern).Groups["movieRuntime"].Value);
          int runTime;
          if (int.TryParse(Regex.Match(strTechHtml, regexPattern).Groups["movieRuntime"].Value, out runTime))
          {
            movieDetails.RunTime = runTime;
          }
        }
        catch (Exception ex)
        {
          Log.Error("{0} GetRunTime error: {1}", strGrabber, ex.Message);
        }
      }

      // Awards MP1-4846
      try
      {
        string _awardsURL  = url.URL + "awards";
        string _awardsPage = string.Empty;
        string _awardsList = string.Empty;

        strAbsUrl = string.Empty;
        _awardsPage = GetPage(_awardsURL, "utf-8", out strAbsUrl);

        if (!string.IsNullOrEmpty(_awardsPage)) 
        {
          string rx_awards_mainblock  = @"<h3>(?<award>[^<]+?)<a href=..event[^>]+?class=.event_year[^>]+?>(?<awardyear>[^<]+?)<(?<block>[\s\S]+?)<\/table>";
          string rx_awards_listWblock = @"<tr>[\s\S]+?>^(?!Nominated)|(Won)<\/b(?<block>[\s\S]+?)<\/tr";
          string rx_awards_listNblock = @"<tr>[\s\S]+?>^(?!Won)|(Nominated)<\/b(?<block>[\s\S]+?)<\/tr";
          string rx_awards_line       = @"award_category.>(?<award>[^<]+?)<[\s\S]+?award_description.>(?<what>[^<]+?)(?:<br.?\/>)?(?<who><[\s\S]+?)<\/td>";
          _awardsPage = HttpUtility.HtmlDecode(_awardsPage);

          ArrayList awardsList = Parse(_awardsPage, rx_awards_mainblock);
          if (awardsList != null && awardsList.Count > 0) 
          {
            for(int i = 0; i < awardsList.Count; i++) 
            {
              Hashtable awardMain   = (Hashtable)awardsList[i];
              string awardMainName  = (string)awardMain["award"]+" "+(string)awardMain["awardyear"];
              string awardMainBlock = (string)awardMain["block"];
              awardMainName = awardMainName.Trim().Replace("\n", "");
              // awardMainName = Regex.Replace(awardMainName, @"&#(?((0?x){1})[\da-hA-H]+|[\d]+);", new MatchEvaluator(ReplaceCharUTF8));
              awardMainName = Utils.stripHTMLtags(awardMainName);

              if (!string.IsNullOrEmpty(awardMainBlock))
              {
                // _awardsList = (string.IsNullOrEmpty(_awardsList) ? "Won:\n" : _awardsList) + awardMainName + "\n"; 
                _awardsList = _awardsList + "* " + awardMainName + "\n"; 
                // Winner
                ArrayList awardsWList = Parse(awardMainBlock, rx_awards_listWblock);
                if (awardsWList != null && awardsWList.Count > 0) 
                {
                  for(int k = 0; k < awardsWList.Count; k++) 
                  {
                    Hashtable awardWMain   = (Hashtable)awardsWList[k];
                    string awardWMainBlock = (string)awardWMain["block"];
                    if (!string.IsNullOrEmpty(awardWMainBlock))
                    {
                      _awardsList = _awardsList + "Won:\n";
                      ArrayList awardsWListLines = Parse(awardWMainBlock, rx_awards_line);
                      if (awardsWListLines != null && awardsWListLines.Count > 0) 
                      {
                        for(int j = 0; j < awardsWListLines.Count; j++) 
                        {
                          Hashtable awardLine  = (Hashtable)awardsWListLines[j];
                          string awardLineName = (string)awardLine["award"];
                          string awardLineWho  = (string)awardLine["who"];
                          string awardLineWhat = (string)awardLine["what"];
                          if (!string.IsNullOrEmpty(awardLineName))
                          {
                            awardLineName = awardLineName.Trim().Replace("\n", "");
                            // awardLineName = Regex.Replace(awardLineName, @"&#(?((0?x){1})[\da-hA-H]+|[\d]+);", new MatchEvaluator(ReplaceCharUTF8));
                            awardLineName = Utils.stripHTMLtags(awardLineName);
                            awardLineName = Regex.Replace(awardLineName, @"[ ]{2,}", " ").Trim();
                          }
                          else
                          {
                            awardLineName = string.Empty;
                          }
                          if (!string.IsNullOrEmpty(awardLineWho))
                          {
                            awardLineWho = awardLineWho.Trim().Replace("\n", "").Replace("</a>", ", ");
                            // awardLineWho = Regex.Replace(awardLineWho, @"&#(?((0?x){1})[\da-hA-H]+|[\d]+);", new MatchEvaluator(ReplaceCharUTF8));
                            awardLineWho = Utils.stripHTMLtags(awardLineWho);
                            awardLineWho = Regex.Replace(awardLineWho, @"[ ]{2,}", " ").Trim();
                          }
                          else
                          {
                            awardLineWho = string.Empty;
                          }
                          if (!string.IsNullOrEmpty(awardLineWhat))
                          {
                            awardLineWhat = awardLineWhat.Trim().Replace("\n", "");
                            // awardLineWhat = Regex.Replace(awardLineWhat, @"&#(?((0?x){1})[\da-hA-H]+|[\d]+);", new MatchEvaluator(ReplaceCharUTF8));
                            awardLineWhat = Utils.stripHTMLtags(awardLineWhat);
                            awardLineWhat = Regex.Replace(awardLineWhat, @"[ ]{2,}", " ").Trim();
                          }
                          else
                          {
                            awardLineWhat = string.Empty;
                          }
                          if (!string.IsNullOrEmpty(awardLineName))
                          {
                            _awardsList = _awardsList + "- " +awardLineName + (string.IsNullOrEmpty(awardLineWho) ? "" : " - " + awardLineWho) + (string.IsNullOrEmpty(awardLineWhat) ? "" : " - " + awardLineWhat) + "\n";
                            Log.Debug("{0} Award (W): {1} - {2} {3} {4}", strGrabber, awardMainName, awardLineName, awardLineWho, awardLineWhat);
                          }
                        }
                      }
                    }
                  }
                }
                // Nominate
                ArrayList awardsNList = Parse(awardMainBlock, rx_awards_listNblock);
                if (awardsNList != null && awardsNList.Count > 0) 
                {
                  for(int k = 0; k < awardsNList.Count; k++) 
                  {
                    Hashtable awardNMain   = (Hashtable)awardsNList[k];
                    string awardNMainBlock = (string)awardNMain["block"];
                    if (!string.IsNullOrEmpty(awardNMainBlock))
                    {
                      _awardsList = _awardsList + "Nominated:\n";
                      ArrayList awardsNListLines = Parse(awardNMainBlock, rx_awards_line);
                      if (awardsNListLines != null && awardsNListLines.Count > 0) 
                      {
                        for(int j = 0; j < awardsNListLines.Count; j++) 
                        {
                          Hashtable awardLine  = (Hashtable)awardsNListLines[j];
                          string awardLineName = (string)awardLine["award"];
                          string awardLineWho  = (string)awardLine["who"];
                          string awardLineWhat = (string)awardLine["what"];
                          if (!string.IsNullOrEmpty(awardLineName))
                          {
                            awardLineName = awardLineName.Trim().Replace("\n", "");
                            // awardLineName = Regex.Replace(awardLineName, @"&#(?((0?x){1})[\da-hA-H]+|[\d]+);", new MatchEvaluator(ReplaceCharUTF8));
                            awardLineName = Utils.stripHTMLtags(awardLineName);
                            awardLineName = Regex.Replace(awardLineName, @"[ ]{2,}", " ").Trim();
                          }
                          else
                          {
                            awardLineName = string.Empty;
                          }
                          if (!string.IsNullOrEmpty(awardLineWho))
                          {
                            awardLineWho = awardLineWho.Trim().Replace("\n", "").Replace("</a>", ", ");
                            // awardLineWho = Regex.Replace(awardLineWho, @"&#(?((0?x){1})[\da-hA-H]+|[\d]+);", new MatchEvaluator(ReplaceCharUTF8));
                            awardLineWho = Utils.stripHTMLtags(awardLineWho);
                            awardLineWho = Regex.Replace(awardLineWho, @"[ ]{2,}", " ").Trim();
                          }
                          else
                          {
                            awardLineWho = string.Empty;
                          }
                          if (!string.IsNullOrEmpty(awardLineWhat))
                          {
                            awardLineWhat = awardLineWhat.Trim().Replace("\n", "");
                            // awardLineWhat = Regex.Replace(awardLineWhat, @"&#(?((0?x){1})[\da-hA-H]+|[\d]+);", new MatchEvaluator(ReplaceCharUTF8));
                            awardLineWhat = Utils.stripHTMLtags(awardLineWhat);
                            awardLineWhat = Regex.Replace(awardLineWhat, @"[ ]{2,}", " ").Trim();
                          }
                          else
                          {
                            awardLineWhat = string.Empty;
                          }
                          if (!string.IsNullOrEmpty(awardLineName))
                          {
                            _awardsList = _awardsList + "- " + awardLineName + (string.IsNullOrEmpty(awardLineWho) ? "" : " - " + awardLineWho) + (string.IsNullOrEmpty(awardLineWhat) ? "" : " - " + awardLineWhat) + "\n";
                            Log.Debug("{0} Award (N): {1} - {2} {3} {4}", strGrabber, awardMainName, awardLineName,awardLineWho,awardLineWhat);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (!string.IsNullOrEmpty(_awardsList))
        {
          movieDetails.MovieAwards = _awardsList; // MP1-4846
        }
      }
      catch (Exception ex)
      {
        Log.Error("{0} GetAwards error: {1}", strGrabber, ex.Message);
      }

      //User review
      //string reviewUrl = "https://www.imdb.com/title/" + movieDetails.IMDBNumber +
      //                   "/usercomments?filter=best&spoiler=hide";
      //strBody = GetPage(reviewUrl, "utf-8", out strAbsUrl);
      //regexPattern = "<a\\shref=\"/user/.*?<p>(?<review>.*?)</p>";
      regexPattern = @"<p\sitemprop=""reviewBody"">(?<review>.*?)</p>";
      Match strReview = Regex.Match(HttpUtility.HtmlDecode(strBody), regexPattern, RegexOptions.Singleline);

      if (strReview.Success)
      {
        string review = Utils.stripHTMLtags(strReview.Groups["review"].Value.Replace("\n", " ").Trim());
        movieDetails.UserReview = HttpUtility.HtmlDecode(review);
      }

      Log.Info("{0} Get info for {1} succeded.", strGrabber, movieDetails.Title);
      return true;
    }
    catch (Exception ex)
    {
      Log.Error("{0} GetDetails error: {1}", strGrabber, ex.Message);
    }
    return false;
  }

  public string GetName()
  {
    return "IMDB V1.17.x v" + strGrabberVersion;
  }

  public string GetLanguage()
  {
    return "EN";
  }

  private static string GetStudiosIMDB(string page)
  {
    if (string.IsNullOrEmpty(page))
    {
      return string.Empty;
    }
    string _studios = string.Empty;

    // string rx_block = @"<h4\sclass=.inline.>Production\sCo:<\/h4>.*?href=.companycredits";
    string rx_block = @"href=[^>]+?companycredits[^>]+?>Production companies<\/a>.+?aria-label=.See more.";
    string rx_line = @"href=.[^>]+?company[^>]+?>(?:<span[^>]+?>)?(?<movieStudios>[^<]+?)<";
    string block = Regex.Match(page, rx_block, RegexOptions.Singleline).Value;

    ArrayList studioList = Parse(block, rx_line);
    if (studioList != null && studioList.Count > 0)
    {
      for (int i = 0; i < studioList.Count; i++)
      {
        Hashtable studioMain = (Hashtable)studioList[i];
        string studio = (string)studioMain["movieStudios"];
        if (!string.IsNullOrEmpty(studio))
        {
          studio = studio.Trim().Replace("\n", string.Empty);
          studio = Utils.stripHTMLtags(studio);
          studio = HttpUtility.HtmlDecode(studio);
          studio = Regex.Replace(studio, @"[ ]{2,}", " ").Replace(", ", " ").Trim();
          _studios = _studios + (string.IsNullOrEmpty(_studios) ? string.Empty : " / ") + studio;
        }
      }
    }

    if (!string.IsNullOrEmpty(_studios))
    {
      Log.Debug("{0} IMDB Studios: {1}", strGrabber, _studios);
    }

    return _studios;
  }

  private static string GetMPARatingText(string IMDBPage)
  {
    string page = IMDBPage;
    if (string.IsNullOrEmpty(page))
    {
      return string.Empty;
    }

    string mpaaText = string.Empty;

    // MP1-4846 MPAA Text
    string regexPattern = @"mpaa-rating[\s\S]+?MPAA<\/td[^<]+?<td>(?<CertDesc>[^<]+?)<";
    string CertDescription = Regex.Match(page, regexPattern).Groups["CertDesc"].Value;
    if (!string.IsNullOrEmpty(CertDescription))
    {
      mpaaText = CertDescription.Replace("\n", " ");
      Log.Debug("{0} MPAA Description: {1}", strGrabber, CertDescription.Replace("\n", " "));
    }

    // MP1-4846 MPAA Description
    string MPAADesc = string.Empty;
    string rx_mpaa_block = @"section.id=.advisory\-(?!spoiler[s\-])(?<block>[\s\S]+?)<\/section>\s+?<\/section>\s+?<\/section";
    string rx_mpaa_header = @"h4.class=.ipl-list-title.>(?<header>[^<]+?)<\/h4";
    string rx_mpaa_line = @"li.class=.ipl-zebra-list[^>]+?>(?<text>[\s\S]+?)<div class=";

    ArrayList mpaaList = Parse(page, rx_mpaa_block);
    if (mpaaList != null && mpaaList.Count > 0)
    {
      for (int i = 0; i < mpaaList.Count; i++)
      {
        Hashtable mpaaMain = (Hashtable)mpaaList[i];
        string mpaaMainBlock = (string)mpaaMain["block"];
        if (!string.IsNullOrEmpty(mpaaMainBlock))
        {
          string mpaaHeader = Regex.Match(mpaaMainBlock, rx_mpaa_header).Groups["header"].Value;
          ArrayList mpaaLines = Parse(mpaaMainBlock, rx_mpaa_line);
          if (mpaaLines != null && mpaaLines.Count > 0)
          {
            MPAADesc = MPAADesc + "* " + mpaaHeader + "\n";
            for (int j = 0; j < mpaaLines.Count; j++)
            {
              Hashtable mpaaLine = (Hashtable)mpaaLines[j];
              string mpaaLineText = (string)mpaaLine["text"];
              if (!string.IsNullOrEmpty(mpaaLineText) && !Regex.IsMatch(mpaaLineText, @"\d+?\/\d+?"))
              {
                mpaaLineText = mpaaLineText.Trim().Replace("\n", string.Empty);
                mpaaLineText = Utils.stripHTMLtags(mpaaLineText);
                mpaaLineText = mpaaLineText.Trim();
                MPAADesc = MPAADesc + mpaaLineText + "\n";
              }
            }
          }
        }
      }
    }

    if (!string.IsNullOrEmpty(MPAADesc))
    {
      MPAADesc = HttpUtility.HtmlDecode(MPAADesc);
      MPAADesc = Utils.stripHTMLtags(MPAADesc);
      mpaaText = mpaaText + "\n\n" + MPAADesc;
      Log.Debug("{0} MPAA Text: {1}", strGrabber, MPAADesc.Replace("\n", " "));
    }

    return mpaaText;
  }

  private ArrayList Parse(string input, string pattern) 
  {
    ArrayList keyedMatches = new ArrayList();
    try 
    {
      Regex regEx             = new Regex(pattern, RegexOptions.IgnoreCase | RegexOptions.Singleline);
      MatchCollection matches = regEx.Matches(input);
      
      // write matches and groups to variables
      foreach (Match currMatch in matches) 
      {
        // store the groups in the match
        if (currMatch.Groups.Count > 1) 
        {
          Hashtable groupings = new Hashtable( );
          for (int i = 1; i < currMatch.Groups.Count; i++)
          {
            groupings.Add(regEx.GroupNameFromNumber(i), currMatch.Groups[i].Value.Trim());
          }
          keyedMatches.Add(groupings);
        }
      }
    }
    catch (Exception e) 
    {
      Log.Error("{0} Regex expression failed! Exception: {1}", strGrabber, e.Message);
      Log.Error(e);
    }
    return keyedMatches;
  }

  private string GetPage(string strUrl, string strEncode, out string absoluteUri)
  {
    string strBody = string.Empty;
    absoluteUri = string.Empty;
    Stream receiveStream = null;
    StreamReader sr = null;
    WebResponse result = null;
    try
    {
      // Make the Webrequest
      //Log.Info("IMDB: get page:{0}", strURL);
      HttpWebRequest req = (HttpWebRequest)WebRequest.Create(strUrl);
      string uu = "BCYmcFe4PTBQ8nEoIcCgT5AJwPk7BAOCg5XsQrvqKyvxEUpEB6KqjE0Uv_pqnPChVCCnD8vgTK3UtK7FGCdw39E2j-Fb5MWegRLgbNA2rFWeYUJbbXhRyUaxqGuuW3AZb1grBhmGMxhDJyH5ntFDj1X1Ejh_jqR6BaQUk6P16AN1EMPstTSBIqxVW08QEqMKQgsK75y8_s1Ss9tyDfZpLZzCWhO5qftGUn3_bbw_DBF6sTZDo6xK-zy88VZ8cws-D30P";
      string id = "BCYobsJMWRwG55i2yGvVuZe7v5twryi7KSxLglDHw2wVcI1rMq0OjHVT7duPo5NNHKDDVFBTVjJM4PoMonlTB_q9NvMCs-wB78Y1hGjdgCLX0SEEC2Y6BD4E3Z6cIoMwlhTDFSprYlxMqjEsFGYwWzVp1oIUYkZQ0kgpX_MvBrEh-fU";
      string cookieHeader = string.Format("uu={0}; id={1}", uu, id);
      req.Headers.Add("Cookie", cookieHeader);
      req.Headers.Add("Accept-Language", "en-US,en;q=0.5");
      req.Timeout = 20000;
      req.ReadWriteTimeout = 20000;

      result = req.GetResponse();
      receiveStream = result.GetResponseStream();

      // Encoding: depends on selected page
      Encoding encode = System.Text.Encoding.GetEncoding(strEncode);

      using (sr = new StreamReader(receiveStream, encode))
      {
        strBody = sr.ReadToEnd();
      }

      absoluteUri = result.ResponseUri.AbsoluteUri;
    }
    catch (Exception ex)
    {
      Log.Error("{0} Error retreiving WebPage: {1} Encoding:{2} err:{3} stack:{4}", strGrabber, strUrl, strEncode, ex.Message, ex.StackTrace);
    }
    finally
    {
      if (sr != null)
      {
        try
        {
          sr.Close();
        }
        catch (Exception) { }
      }
      if (receiveStream != null)
      {
        try
        {
          receiveStream.Close();
        }
        catch (Exception) { }
      }
      if (result != null)
      {
        try
        {
          result.Close();
        }
        catch (Exception) { }
      }
    }
    return strBody;
  }

  #region IMDB Parameters

  private const string IMDB_BaseUrl = "https://www.imdb.com/title/{0}/";

  #endregion IMDB Parameters

  #region IMDB Const

  public const string IMDB_Find = "https://m.imdb.com/find/?q={0}";
  public const string IMDB_Plot = "https://m.imdb.com/title/{0}/plotsummary/";

  public const string IMDB_Awards = IMDB_BaseUrl + "awards/";
  public const string IMDB_Parents = IMDB_BaseUrl + "parentalguide/";
  public const string IMDB_Trivia = IMDB_BaseUrl + "trivia/";
  public const string IMDB_Review = IMDB_BaseUrl + "reviews/?sort=totalVotes&dir=desc&ratingFilter=0";
  public const string IMDB_Ratings = IMDB_BaseUrl + "ratings/";
  public const string IMDB_Tech = IMDB_BaseUrl + "technical/"

  #endregion IMDB Const

  public class JsonIMDBActor
  {
    [JsonProperty("@type")]
    public string type { get; set; }
    public string url { get; set; }
    public string name { get; set; }
  }

  public class JsonIMDBAggregateRating
  {
    [JsonProperty("@type")]
    public string type { get; set; }
    public int ratingCount { get; set; }
    public int bestRating { get; set; }
    public int worstRating { get; set; }
    public double ratingValue { get; set; }
  }

  public class JsonIMDBMovie
  {
    [JsonProperty("@context")]
    public string context { get; set; }

    [JsonProperty("@type")]
    public string type { get; set; }
    public string url { get; set; }
    public string name { get; set; }
    public string alternateName { get; set; }
    public string image { get; set; }
    public string description { get; set; }
    public AggregateRating aggregateRating { get; set; }
    public string contentRating { get; set; }
    public List<string> genre { get; set; }
    public string datePublished { get; set; }
    public string keywords { get; set; }
    public List<Actor> actor { get; set; }
    public List<Actor> director { get; set; }
    public List<Actor> creator { get; set; }
    public string duration { get; set; }
  }

}
